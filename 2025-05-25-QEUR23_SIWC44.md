---
title: QEUR23_SIWC44 - 最適化作業を自動化する
date: 2025-05-25
tags: ["QEUシステム", "メトリックス", "Python言語", "Unsloth", "LLM", "データセット", "BONSAI", "LangGraph"]
excerpt: あたらしいLLMの学習体系を確立する
---

## QEUR23_SIWC44 - 最適化作業を自動化する

## ～ ここまで最適化が自動化するとうれしい！ ～

D先生： “それでは、T法(2)のロジックとLLM（大規模言語モデル）を使って最適化の自動化をやってみましょう。今回も、前回と同じ事例（おいしいビール：↓）ですね。”

![imageSIWC2-44-1](/2025-05-23-QEUR23_SIWC43/imageSIWC2-44-1.jpg) 

QEU:FOUNDER ： “「最適化の自動化」というのは、以下のような繰り返しのある解析フローになります。”

![imageSIWC2-44-2](/2025-05-23-QEUR23_SIWC43/imageSIWC2-44-2.jpg) 

QEU:FOUNDER： “ユーザープロンプトを見てみましょう。本システムには**2つのプロンプト**があります。”

```python
# ---
# ユーザープロンプト（初期のクエリ）
str_query = """
以下のような実験をしました。この実験の生データを、数量化一類の考えにより展開して、「単位空間」、「信号空間」の表を生成しました。
これらのデータを使ってT法に基づいて解析し、予測に使用するすべての項目のβとηの値を表形式で出力してください。
そのβとηを使用して、応答変数の値を最大にする有意な項目（説明変数）と応答変数を最小にする有意な項目を見出してください。
その結果をもとに、最適化（最大、最小）を実施するための、説明変数の水準を提案してください。
```
## プロジェクト名 : ビールの満足度の最大化

## プロジェクトの目的 : 顧客満足度を最大化する

## 実験の生データ表

**(応答変数：出力[Y])**

満足度

**(説明変数：項目[Xs])**

| NO | 実験項目 | 現状の水準 |
|----|--------|----------|
| 1 |  容器  |  びん  |
| 2 |  あわ  |  ふつう  |
| 3 |  色  |  ふつう  |
| 4 |  ホップ  |  ふつう  |
| 5 | 飲みごたえ | コクがある |
| 6 |  価格  |  230円  |


**(変換前のデータ表)**

| NO/実験項目 | 容器   | あわ   | 色     | ホップ   | 飲みごたえ   | 価格   |   満足度 |
|-----:|:-------|:-------|:-------|:-------|:-----------|:-------|-------:|
|    1 | びん   | 大きい | 薄目   | 少なめ   | コクがある   | 230円  |      3.6 |
|    2 | びん   | 大きい | ふつう | ふつう   | 苦味         | 220円  |      2.2 |
|    3 | びん   | 大きい | 濃い目 | 多め     | キレ味       | 210円  |      5.2 |
|    4 | びん   | ふつう | 薄目   | 少なめ   | 苦味         | 220円  |      2.2 |
|    5 | びん   | ふつう | ふつう | ふつう   | キレ味       | 210円  |      6.2 |
|    6 | びん   | ふつう | 濃い目 | 多め     | コクがある   | 230円  |      6   |
|    7 | びん   | 細かい | 薄目   | ふつう   | コクがある   | 210円  |      6.3 |
|    8 | びん   | 細かい | ふつう | 多め     | 苦味         | 230円  |      3.5 |
|    9 | びん   | 細かい | 濃い目 | 少なめ   | キレ味       | 220円  |      5.6 |
|   10 | 缶     | 大きい | 薄目   | 多め     | キレ味       | 220円  |      4.1 |
|   11 | 缶     | 大きい | ふつう | 少なめ   | コクがある   | 210円  |      5   |
|   12 | 缶     | 大きい | 濃い目 | ふつう   | 苦味         | 230円  |      1.9 |
|   13 | 缶     | ふつう | 薄目   | ふつう   | キレ味       | 230円  |      5.2 |
|   14 | 缶     | ふつう | ふつう | 多め     | コクがある   | 220円  |      6.3 |
|   15 | 缶     | ふつう | 濃い目 | 少なめ   | 苦味         | 210円  |      3.1 |
|   16 | 缶     | 細かい | 薄目   | 多め     | 苦味         | 210円  |      2.9 |
|   17 | 缶     | 細かい | ふつう | 少なめ   | キレ味       | 230円  |      5.6 |
|   18 | 缶     | 細かい | 濃い目 | ふつう   | コクがある   | 220円  |      6.3 |

## 数量化一類で変換したデータ表

### 応答変数、従属変数(Y)

- Y : 満足度

### 説明変数(Xs)

| NO  | 記号 |  項目(実験項目:水準)  |
|-----|-----|---------|
| 1  | A1 |  容器:缶   | 
| 2  | B2 |  あわ:大きい | 
| 3  | C3 |  あわ:細かい | 
| 4  | D4 |  色:薄目 | 
| 5  | E5 |  色:濃い目 | 
| 6  | F6 |  ホップ:少なめ | 
| 7  | G7 |  ホップ:多め | 
| 8  | H8 |  飲みごたえ:苦味 | 
| 9  | I9 |  飲みごたえ:キレ味 | 
| 10  | J10 |  価格:220円  | 
| 11  | K11 |  価格:210円  | 


### 単位空間

| NO/項目 |   A1 |       B2 |       C3 |       D4 |       E5 |   F6 |   G7 |       H8 |       I9 |   J10 |      K11 |       Y |
|:-------|-----:|---------:|---------:|---------:|---------:|-----:|-----:|---------:|---------:|------:|---------:|--------:|
| 1      |  0   | 1        | 0        | 0        | 1        |  0   |  1   | 0        | 0        |   0   | 0        | 3.6     |
| 3      |  0   | 1        | 0        | 1        | 0        |  1   |  0   | 1        | 0        |   1   | 0        | 5.2     |
| 8      |  0   | 0        | 1        | 0        | 0        |  1   |  0   | 0        | 1        |   0   | 0        | 3.5     |
| 10     |  1   | 1        | 0        | 0        | 1        |  1   |  0   | 1        | 0        |   0   | 1        | 4.1     |
| 11     |  1   | 1        | 0        | 0        | 0        |  0   |  1   | 0        | 0        |   1   | 0        | 5       |
| 15     |  1   | 0        | 0        | 1        | 0        |  0   |  1   | 0        | 1        |   1   | 0        | 3.1     |


### 信号空間

|   NO |   A1 |   B2 |   C3 |   D4 |   E5 |   F6 |   G7 |   H8 |   I9 |   J10 |   K11 |   Y |
|-----:|-----:|-----:|-----:|-----:|-----:|-----:|-----:|-----:|-----:|------:|------:|----:|
|    2 |    0 |    1 |    0 |    0 |    0 |    0 |    0 |    0 |    1 |     0 |     1 | 2.2 |
|    4 |    0 |    0 |    0 |    0 |    1 |    0 |    1 |    0 |    1 |     0 |     1 | 2.2 |
|    5 |    0 |    0 |    0 |    0 |    0 |    0 |    0 |    1 |    0 |     1 |     0 | 6.2 |
|    6 |    0 |    0 |    0 |    1 |    0 |    1 |    0 |    0 |    0 |     0 |     0 | 6   |
|    9 |    0 |    0 |    1 |    1 |    0 |    0 |    1 |    1 |    0 |     0 |     1 | 5.6 |
|   12 |    1 |    1 |    0 |    1 |    0 |    0 |    0 |    0 |    1 |     0 |     0 | 1.9 |
|   13 |    1 |    0 |    0 |    0 |    1 |    0 |    0 |    1 |    0 |     0 |     0 | 5.2 |
|   16 |    1 |    0 |    1 |    0 |    1 |    1 |    0 |    0 |    1 |     1 |     0 | 2.9 |
|   17 |    1 |    0 |    1 |    0 |    0 |    0 |    1 |    1 |    0 |     0 |     0 | 5.6 |

"""

```

D先生： “これは、実験データの入力です。例によって、**数量化一類の考え方**をつかっています。もう一つのプロンプトがあるんですか？”

```python
# ---
# T2法による最適化の実行ポリシー
str_t2policy = """
- **繰り返し最適化**：少ない信号データからはじめて、その都度に計算された最大化及び最小化に寄与する有意な項目を参考にして新しい実験データを採取する。その実験データを信号空間と単位空間に組み込む。この作業を数回繰り返しすることが望ましい
- 有意な項目とはSN比(η)が0.5を超える(η>0.5)項目のことである
- 最大化に寄与する有意な項目とは感度(β)が正(β>=0)値である有意な項目のことである。感度(β)が負(β<0)値である項目を外すこと。
- 最小化に寄与する有意な項目とは感度(β)が負(β<0)値である有意な項目のことである。感度(β)が正(β>0)値である項目を外すこと。
- **最大化及び最小化データ活用の必要性**：たとえ最適化が最大化を意味する場合であっても、本ツールから得られる最小化のデータを活用するのが望ましい。最小化の実験データを重要因子の検出処理に加えると、感度とSN比の予測精度が大いに向上するためである
- **実験と計算の繰り返しの判定**：ユーザーが、まだ最適条件を得られていないと考えた場合には、繰り返し最適化の段階に戻る。
- **最適化の完了の判定**：ユーザーが最適化を達成したと考えた場合に繰り返しを完了する。その場合は、以下の3つのケースがありうる：
  1. ηの値が十分に大きく(η>3.0)、予測精度が今後も変わらないと考えられる「最大化に寄与する有意な項目」が2つ以上ある
  2. ηが小さいが、3回以上回も最適化実験を繰り返してもβのプラス・マイナス傾向が変わらないと考えられる項目が2つ以上ある
  3. その他、コストと手間を考え、ユーザーの都合で不必要な項目をすべて外したいとき       

"""

```

D先生： “**「T2法による最適化の実行ポリシー」**とは？ “

QEU:FOUNDER： “この最適化の作業において、調整する可能性のある「ルール」を外部にまとめたのです。特にSN比の大きさと処理に関するポリシーは、実際のところケースバイケースだと思います。何はともあれ、プログラムをみてみましょう。先ほどの2つのプロンプトは、ちょっと外しておきます。”


```python
# ----
import os
import pandas as pd
import numpy as np
from pydantic import BaseModel, Field, ConfigDict
from langchain_core.prompts import PromptTemplate
from langchain_openai import ChatOpenAI
from langchain_core.runnables import RunnableLambda, RunnablePassthrough
from typing import Union, List, Dict, Any

# Qwenモデルの初期化
llm = ChatOpenAI(
    model="qwen-max",
    temperature=0.0,
    openai_api_key=os.getenv("DASHSCOPE_API_KEY"),
    openai_api_base="https://dashscope-intl.aliyuncs.com/compatible-mode/v1",
)

# Pydanticモデル定義
class ProjectInfo(BaseModel):
    name: str = Field(description="プロジェクト名")
    purpose: str = Field(description="プロジェクト目的")

class VariableItem(BaseModel):
    code: str = Field(description="変数コード（例: A1, B2）")
    variable: str = Field(description="変数名（例: 容器, あわ）")
    level: str = Field(description="水準（例: 缶, 大きい）")

class VariablesInfo(BaseModel):
    response_variable: str = Field(description="応答変数(Y)説明")
    explanatory_variables: List[VariableItem] = Field(description="説明変数(Xs)リスト")

class TableRow(BaseModel):
    NO: Union[str, int] = Field(alias="NO/項目")  # エイリアスを「NO\\項目」→「NO/項目」に変更
    A1: Union[float, str]
    B2: Union[float, str]
    C3: Union[float, str]
    D4: Union[float, str]
    E5: Union[float, str]
    F6: Union[float, str]
    G7: Union[float, str]
    H8: Union[float, str]
    I9: Union[float, str]
    J10: Union[float, str]
    K11: Union[float, str]
    Y: Union[float, str]
    model_config = ConfigDict(
        populate_by_name=True,
        arbitrary_types_allowed=True
    )


class TableData(BaseModel):
    rows: List[TableRow] = Field(description="表データ行")

# プロンプトテンプレート
project_prompt = PromptTemplate.from_template(
    "テキストからプロジェクト名と目的を抽出してください。\n"
    "JSON形式で'name'と'purpose'キーを使用してください。\n"
    "{text}"
)

variables_prompt = PromptTemplate.from_template(
    "応答変数と説明変数を抽出してください。\n"
    "応答変数(Y)は'{response_var}'です。\n"
    "以下の表形式から説明変数を抽出し、JSON形式で出力してください：\n"
    "- response_variable: 応答変数の説明\n"
    "- explanatory_variables: リスト形式（各要素はcode/variable/levelを含む）\n"
    "\n"
    "抽出元表例：\n"
    "| NO | 記号 | 項目(実験項目:水準) |\n"
    "|----|-----|-------------------|\n"
    "| 1  | A1  | 容器:缶           |\n"
    "\n"
    "抽出結果例：\n"
    "{{\n"
    "  \"response_variable\": \"満足度\",\n"
    "  \"explanatory_variables\": [\n"
    "    {{\"code\": \"A1\", \"variable\": \"容器\", \"level\": \"缶\"}}\n"
    "  ]\n"
    "}}\n"
    "\n"
    "実際のデータ：\n"
    "{text}"
)

table_prompt = PromptTemplate.from_template(
    "表データを抽出してください。\n"
    "JSON形式で'rows'キーにリスト形式で行データを含めてください。\n"
    "カラム名は厳密に元データの表記を保持してください。\n"
    "{text}"
)

# チェーン定義
project_chain = (
    {"text": RunnablePassthrough()} 
    | project_prompt 
    | llm.with_structured_output(ProjectInfo)
)

variables_chain = (
    {"text": RunnablePassthrough(), "response_var": RunnablePassthrough()}
    | variables_prompt 
    | llm.with_structured_output(VariablesInfo)
)

table_chain = (
    {"text": RunnablePassthrough()} 
    | table_prompt 
    | llm.with_structured_output(TableData)
)

def extract_all_data(text: str) -> Dict[str, Any]:
    """全データ抽出関数"""
    # プロジェクト情報抽出
    project_info = project_chain.invoke(text)
    
    # 変数情報抽出
    variables_info = variables_chain.invoke({
        "text": text,
        "response_var": "Y : 満足度"
    })
    
    # 単位空間抽出
    unit_table_text = text.split("## 単位空間")[1].split("##")[0]
    unit_data = table_chain.invoke("## 単位空間" + unit_table_text)
    
    # 信号空間抽出
    signal_table_text = text.split("## 信号空間")[1].split("##")[0]
    signal_data = table_chain.invoke("## 信号空間" + signal_table_text)
    
    # DataFrame作成後に数値列を明示的に変換
    def convert_columns(df):
        numeric_cols = ['A1', 'B2', 'C3', 'D4', 'E5', 'F6', 'G7', 'H8', 'I9', 'J10', 'K11', 'Y']
        for col in numeric_cols:
            df[col] = pd.to_numeric(df[col], errors='coerce')
        return df
    
    unit_df = pd.DataFrame([row.model_dump(by_alias=True) for row in unit_data.rows])
    signal_df = pd.DataFrame([row.model_dump(by_alias=True) for row in signal_data.rows])
    
    unit_df = convert_columns(unit_df)
    signal_df = convert_columns(signal_df)
    
    return {
        "project_info": project_info,
        "variables_info": variables_info,
        "unit_space": unit_df,
        "signal_space": signal_df
    }


class TMethodCalculator:
    def __init__(self, unit_space: pd.DataFrame, signal_space: pd.DataFrame):
        self.unit_space = unit_space
        self.signal_space = signal_space
        self.unit_avg = unit_space[['A1', 'B2', 'C3', 'D4', 'E5', 'F6', 'G7', 'H8', 'I9', 'J10', 'K11', 'Y']].mean()
        
    def normalize_data(self):
        """信号空間データの正規化"""
        normalized = self.signal_space.copy()
        for col in ['A1', 'B2', 'C3', 'D4', 'E5', 'F6', 'G7', 'H8', 'I9', 'J10', 'K11', 'Y']:
            normalized[col] = normalized[col].astype(float) - self.unit_avg[col]
        return normalized
    
    def calculate_metrics(self):
        """T法メトリクス計算"""
        normalized = self.normalize_data()
        Y_norm = normalized['Y'].values
        
        metrics = {}
        for var in ['A1', 'B2', 'C3', 'D4', 'E5', 'F6', 'G7', 'H8', 'I9', 'J10', 'K11']:
            X_norm = normalized[var].astype(float).values
            
            # ST（全変動）計算
            ST = np.sum(X_norm**2)
            
            # SB（比例項）計算
            numerator = np.sum(X_norm * Y_norm)
            r = np.sum(Y_norm**2)
            SB = (numerator**2) / r if r != 0 else 0
            
            # SE（誤差変動）計算
            SE = ST - SB
            
            # VE（誤差分散）計算
            l = len(normalized)
            VE = SE / (l - 1) if (l - 1) != 0 else 0
            
            # β（感度）計算
            beta = numerator / r if r != 0 else 0
            
            # η（SN比）計算
            eta = SB / VE if VE != 0 else 0
            
            metrics[var] = {
                'ST': ST,
                'SB': SB,
                'SE': SE,
                'VE': VE,
                'beta': beta,
                'eta': eta
            }
        
        return metrics

def generate_optimization_recommendations(metrics: dict, threshold=0.5):
    """最適化推奨生成"""
    significant_vars = {k: v for k, v in metrics.items() if abs(v['eta']) > threshold}
    
    # 最大化・最小化変数分類
    max_vars = {k: v for k, v in significant_vars.items() if v['beta'] > 0}
    min_vars = {k: v for k, v in significant_vars.items() if v['beta'] < 0}
    
    return {
        "有意変数": significant_vars,
        "最大化推奨": max_vars,
        "最小化推奨": min_vars
    }


def create_optimization_report(str_query: str, str_t2policy: str, optimization_prompt: str, data: dict, metrics: dict):

    # ---
    # 指定されたキーワード「## 数量化一類で変換したデータ表」以前の内容を抽出
    keyword = "### 単位空間"

    # キーワードの位置を検索し、それ以前の内容を取得
    filtered_content = str_query.split(keyword)[0]
    
    """最適化レポート生成"""
    # メトリクスをテーブル形式に変換
    metrics_table = pd.DataFrame(metrics).T.round(3)
    metrics_table.index.name = '変数'
    
    # プロンプト入力作成
    prompt_input = {
        "project_name": data["project_info"].name,
        "project_purpose": data["project_info"].purpose,
        "metrics_table": metrics_table.to_markdown(),
        "filtered_content": filtered_content,  # Add this
        "str_t2policy": str_t2policy           # Add this
    }
    
    # チェーン実行
    chain = (
        RunnableLambda(lambda _: prompt_input) 
        | optimization_prompt 
        | llm
    )
    
    return chain.invoke({})

# メイン関数
def main(str_t2policy: str, str_query: str):

    # ---
    # 最適化レポートの生成用のプロンプト
    optimization_prompt = PromptTemplate.from_template(
        """あなたは、T法を使った最適化の作業に熟知している製品、プロセスの開発エンジニアです。
        あなたは、以下の「T法を使った最適化の進め方」の要求事項を十分に理解しています。
        以下に与えられた実験情報とT法分析結果に基づき、以下の分析をしてください。

        (1)初期のユーザークエリ：
        {filtered_content}
        
        (2)T法のメトリックス計算結果:
        {metrics_table}
        
        (3)T法を使った最適化の進め方:
        {str_t2policy}
        
        分析には以下の内容を含めてください：
        1. 上記の「(1)初期のユーザークエリ」から抽出した、実験生データの「実験項目 x 現状の水準（説明変数）」型式のマトリックス表を表示すること 
        2. 上記の「(1)初期のユーザークエリ」から抽出した、数量化一類で変換したデータ表の「記号(A1,B2,...) x 項目(実験項目:水準)」型式のマトリックス表を表示すること 
        3. 上記の「(2)T法のメトリックス計算結果」から抽出した、「記号(A1,B2,...) x メトリックス（ST,SB,SE,VE,β、η）」型式のマトリックス表を表示すること
        4. 上記のβ、ηマトリックス表から、最大化と最小化に寄与する有意な項目を抽出し、その項目が重要であることに対する技術的な説明をすること(注意1)
        5. 最大化のための推奨水準を「実験項目 x 推奨水準」型式のマトリックス表を表示すること(注意2)
        6. 最小化のための推奨水準を「実験項目 x 推奨水準」型式のマトリックス表を表示すること(注意3)
        7. 繰り返し実験が必要か？すでに最適値に達しており繰り返し実験が不要か？その判断と理由を説明してください。
        
        注意1：今回のプロジェクトは出力(Y)の最大化ですが、Ｔ法の予測精度向上のために最小化データも同様に必要になります。
        注意2：最大化のための推奨水準は、現状の水準（説明変数）をベースとして、最大化に寄与する有意な水準だけを入れ替えたものです
        注意3：最小化のための推奨水準は、現状の水準（説明変数）をベースとして、最小化に寄与する有意な水準だけを入れ替えたものです
        """
    )

    # ---
    # データ抽出
    data = extract_all_data(str_query)
    
    # T法計算
    calculator = TMethodCalculator(
        unit_space=data["unit_space"],
        signal_space=data["signal_space"]
    )
    
    metrics = calculator.calculate_metrics()
    
    # 最適化推奨生成
    recommendations = generate_optimization_recommendations(metrics, threshold=0.5)
    
    # LLMによる解説生成
    report = create_optimization_report(str_query, str_t2policy, optimization_prompt, data, metrics)
    
    return {
        "プロジェクト情報": data["project_info"],
        "変数情報": data["variables_info"],
        "メトリクス": metrics,
        "推奨内容": recommendations,
        "レポート": report.content
    }

```

D先生： “なるほど、最適化レポートを生成するためのプロンプトが重要です。ケース次第で変える必要がありそうです。 “

![imageSIWC2-44-3](/2025-05-23-QEUR23_SIWC43/imageSIWC2-44-3.jpg) 

QEU:FOUNDER： “じゃあ、どのような結果がでてくるか。プログラムのラスト部分です。”

```python
# ---
# MAINの実行
results = main(str_t2policy, str_query)

# ---
from IPython.display import Markdown

# ---
print("==== 最適化レポート ====\n")
Markdown(results["レポート"])

```

QEU:FOUNDER ： “結果が出てきました。イケているでしょう？”

![imageSIWC2-44-4](/2025-05-23-QEUR23_SIWC43/imageSIWC2-44-4.jpg) 

D先生： “**最適化の繰り返し実験の必要性を提案してくれる**んですね。“

QEU:FOUNDER ： “これは、先ほどの「最適化ポリシー」のプロンプトに基づいて行われます。もうちょっと細かく見てみましょう。”

---

==== 最適化レポート ====
### 分析結果

以下、順を追って分析結果を示します。

---

### **1. 実験生データの「実験項目 x 現状の水準（説明変数）」型式のマトリックス表**

| 実験項目 | 現状の水準 |
|----------|------------|
| 容器     | びん       |
| あわ     | ふつう     |
| 色       | ふつう     |
| ホップ   | ふつう     |
| 飲みごたえ | コクがある |
| 価格     | 230円      |

---

### **2. 数量化一類で変換したデータ表の「記号(A1,B2,...) x 項目(実験項目:水準)」型式のマトリックス表**

| NO  | 記号 | 項目(実験項目:水準)         |
|-----|------|-----------------------------|
| 1   | A1   | 容器:缶                     |
| 2   | B2   | あわ:大きい                 |
| 3   | C3   | あわ:細かい                 |
| 4   | D4   | 色:薄目                     |
| 5   | E5   | 色:濃い目                   |
| 6   | F6   | ホップ:少なめ               |
| 7   | G7   | ホップ:多め                 |
| 8   | H8   | 飲みごたえ:苦味             |
| 9   | I9   | 飲みごたえ:キレ味           |
| 10  | J10  | 価格:220円                  |
| 11  | K11  | 価格:210円                  |

---

### **3. 「記号(A1,B2,...) x メトリックス（ST,SB,SE,VE,β、η）」型式のマトリックス表**

| 変数   | ST    | SB    | SE    | VE    | β      | η       |
|--------|-------|-------|-------|-------|--------|---------|
| A1     | 2.25  | 0.058 | 2.192 | 0.274 | -0.046 | 0.212   |
| B2     | 3.333 | 0.833 | 2.5   | 0.312 | -0.175 | 2.667   |
| C3     | 2.25  | 0.103 | 2.147 | 0.268 | 0.061  | 0.383   |
| D4     | 2     | 0.03  | 1.97  | 0.246 | 0.033  | 0.121   |
| E5     | 2     | 0.194 | 1.806 | 0.226 | -0.084 | 0.86    |
| F6     | 2.25  | 0.002 | 2.248 | 0.281 | 0.008  | 0.006   |
| G7     | 2.25  | 0.014 | 2.236 | 0.279 | 0.023  | 0.051   |
| H8     | 2.333 | 1.284 | 1.049 | 0.131 | 0.217  | 9.79    |
| I9     | 2.333 | 2.054 | 0.279 | 0.035 | -0.274 | 58.853  |
| J10    | 2.25  | 0.006 | 2.244 | 0.28  | 0.015  | 0.022   |
| K11    | 2.25  | 0.216 | 2.034 | 0.254 | -0.089 | 0.848   |

---

### **4. 最大化と最小化に寄与する有意な項目の抽出と技術的説明**

#### **最大化に寄与する有意な項目**
- **条件**: SN比(η) > 0.5 かつ 感度(β) >= 0
- 抽出結果:
  - H8 (飲みごたえ:苦味): η = 9.79, β = 0.217
  - C3 (あわ:細かい): η = 0.383, β = 0.061
  - D4 (色:薄目): η = 0.121, β = 0.033
  - G7 (ホップ:多め): η = 0.051, β = 0.023
  - J10 (価格:220円): η = 0.022, β = 0.015

**技術的説明**:
- H8 (飲みごたえ:苦味)は、SN比が非常に高く、感度も正であるため、満足度の最大化に最も重要な要因と考えられます。ビールの苦味が適度にあることが消費者の満足度を高める可能性が高いです。
- C3 (あわ:細かい)やD4 (色:薄目)は、感度がわずかに正であり、SN比も低いものの、満足度を向上させる傾向があります。これらの要素は補助的な役割を果たす可能性があります。

#### **最小化に寄与する有意な項目**
- **条件**: SN比(η) > 0.5 かつ 感度(β) < 0
- 抽出結果:
  - I9 (飲みごたえ:キレ味): η = 58.853, β = -0.274
  - E5 (色:濃い目): η = 0.86, β = -0.084
  - K11 (価格:210円): η = 0.848, β = -0.089

**技術的説明**:
- I9 (飲みごたえ:キレ味)は、SN比が極めて高く、感度が負であるため、満足度を低下させる主要な要因と考えられます。キレ味が強すぎると消費者にとって不快感を与える可能性があります。
- E5 (色:濃い目)やK11 (価格:210円)は、感度が負であり、満足度を低下させる傾向があります。特に価格が安すぎる場合、品質への懐疑的な印象を与える可能性があります。

---

### **5. 最大化のための推奨水準**

| 実験項目 | 推奨水準 |
|----------|----------|
| 容器     | びん     |
| あわ     | 細かい   |
| 色       | 薄目     |
| ホップ   | 多め     |
| 飲みごたえ | 苦味     |
| 価格     | 220円    |

---

### **6. 最小化のための推奨水準**

| 実験項目 | 推奨水準 |
|----------|----------|
| 容器     | びん     |
| あわ     | ふつう   |
| 色       | 濃い目   |
| ホップ   | ふつう   |
| 飲みごたえ | キレ味   |
| 価格     | 210円    |

---

### **7. 繰り返し実験が必要か？すでに最適値に達しており繰り返し実験が不要か？その判断と理由**

#### **判断**: 繰り返し実験が必要
#### **理由**:
1. **SN比(η)**: 最大化に寄与する有意な項目の中で、H8 (飲みごたえ:苦味)以外の項目のSN比は比較的低く、まだ予測精度が十分ではない可能性があります。
2. **βの安定性**: βのプラス・マイナス傾向が安定しているかどうかを確認するためには、さらなる実験データの収集が必要です。
3. **最小化データの活用**: 最小化データをさらに活用することで、T法の予測精度を向上させることができます。

以上より、現時点では繰り返し実験を行い、新しい実験データを単位空間と信号空間に組み込むことが望ましいです。

--- 

### **結論**

- 最大化のための推奨水準は、「容器:びん、あわ:細かい、色:薄目、ホップ:多め、飲みごたえ:苦味、価格:220円」です。
- 最小化のための推奨水準は、「容器:びん、あわ:ふつう、色:濃い目、ホップ:ふつう、飲みごたえ:キレ味、価格:210円」です。
- 更なる最適化のために、繰り返し実験を行うことを推奨します。

---

D先生： “必要最小限の内容が記述されています。それにしても、なぜ**「最小化の実験データ」が必要になる**のですか？ “

QEU:FOUNDER ： “最小化のデータが絶対に必要だとは思わないですが、少なくとも繰り返しの最初では追加をしたほうがよいです。その理由は、散布図をみればわかるんです。”

**（SN比が低い項目：繰り返し初期）**

![imageSIWC2-44-5](/2025-05-23-QEUR23_SIWC43/imageSIWC2-44-5.jpg) 

**（SN比が高い項目：繰り返し初期）**

![imageSIWC2-44-6](/2025-05-23-QEUR23_SIWC43/imageSIWC2-44-6.jpg) 

QEU:FOUNDER ： “このβとηの計算ロジックでは、散布図の分布が0点比例式にあることが必要です。逆に言うと、0点比例の回帰線は原点を「テコ(支点)」にして、ぐるぐる回るんです。この場合、右上と左下に均等に実験データが分布することが最もＳＮ比が高くなります。”

D先生： “「左上」と「右下」に同様にプロットが分布するのもＳＮ比が高くなりますね。”

QEU:FOUNDER ： “つまり、「右上だけ」にプロットが分布しても意味がないのです。だから、最初の実験は単位空間が信号空間の中間に分布するように調整しているんです。”

D先生： “なるほど・・・。”

QEU:FOUNDER ： “ちなみに、今回はプロトタイプであり、ぜんぜん完成していないです。「ひな形」にしかすぎません。「TOY-実験」では、できないことが多いんです。”

D先生： “どんなアップデートが必要ですか？”

QEU:FOUNDER ： “繰り返し使うときに、それ以前の実験結果（メトリックス表）の情報を蓄積しておきたいんです。そうしないと、最適化が完了したかどうかの判定ができないんです。”


## ～ まとめ ～

### ・・・ 久々の技術的な会話です ・・・

QEU:FOUNDER ： “LLMの最適化については、大体の方向性が見えてきました。いくつか質問があるそうで・・・？”

![imageSIWC2-44-7](/2025-05-23-QEUR23_SIWC43/imageSIWC2-44-7.jpg) 

C部長： “**交互作用の評価**をどうするんですか？”

QEU:FOUNDER ： “まず重要なことを述べておきたい。T法で交互作用を評価すること自体に矛盾があるんです。**交互作用をデータとして可視化するには多くのデータが必要**だからね。だから、小生のいう**交互作用とは、あくまで「言葉としての表現」にすぎません**。この場合、**「最適化のためのポリシー」**プロンプトにコメントを追加すればいいと思いすよ。**「項目Aと項目Bには正の交互作用があるから、有意なηのしきい値を0.2にします」**とかね・・・。”

C部長： “わかりました。次の質問はコレ（↓）です。これは、データを3つ追加した状態での、MY散布図の状態です。点の分布が0点比例式から外れてきましたよね。”

![imageSIWC2-44-8](/2025-05-23-QEUR23_SIWC43/imageSIWC2-44-8.jpg) 

C部長： “単位空間に（繰り返し評価で得られた）最大化データを追加すると、SN比（η）が悪く評価されるんじゃないんですか？”

QEU:FOUNDER ： “あたたた！ηを高くしたければ、信号空間の分布の中間付近に単位空間を配置する。これが「T法の定石」です。実際に最適化の繰り返し事例を積み上げていないので、いまのところはなんともいえない。すまん・・・（笑）。”

C部長： “まっ、今日のところはこれぐらいで許してやろう（笑）。システム選択に相当するものを、LLMでできないのですか？”

QEU:FOUNDER ： “あくまで理論的には出来ると思うよ。例えば・・・。”

![imageSIWC2-44-9](/2025-05-23-QEUR23_SIWC43/imageSIWC2-44-9.jpg) 

D先生： “これねえ・・・。昔は、**「少しだけ」はやりました**が・・・（笑）。”

![imageSIWC2-44-10](/2025-05-23-QEUR23_SIWC43/imageSIWC2-44-10.jpg) 

QEU:FOUNDER ： “もし、TRIZがそんなに使えるものであるのであれば、こんなこと（↑）になっていないって・・・。ちょっと、Qwenを使って聞いてみようか？”

![imageSIWC2-44-11](/2025-05-23-QEUR23_SIWC43/imageSIWC2-44-11.jpg) 

C部長： “詳細の内容を見てみましょう。”

---

### TRIZ手法の概要と発明事例

#### **TRIZの基本的な考え方**
TRIZ（理論的発明問題解決法）は、1946年にソビエト連邦の技術者ゲンリッヒ・アルトシュラーによって考案された体系的な発明フレームワークです。その核心は、発明プロセスを「偶然」ではなく「法則」に基づいて体系化することです。主な概念は以下の通りです：

1. **矛盾の解消**  
   - **技術的矛盾**：あるパラメータを改善すると別のパラメータが悪化する（例：強度を上げると重量が増す）。  
   - **物理的矛盾**：同じ要素に相反する要件が存在（例：硬さと柔軟性の両立）。  
   - 矛盾を「解消する」ことがイノベーションの鍵とされます。

2. **40の発明的原則**  
   - 矛盾を解消するための汎用的な解決策を40種類に分類（例：分割、統合、逆転、フィードバックなど）。

3. **技術進化の法則**  
   - 技術システムは「動的化」「ミクロ化」「協調化」などの8つのトレンドに沿って進化すると提唱。

4. **分離の原則**  
   - 物理的矛盾を「時間」「空間」「条件」などで分離して解決。

---

#### **TRIZの手順（簡略版）**
1. **問題の定義**  
   - 具体的な課題を明確化し、改善したいパラメータ（例：速度、コスト）と悪化するパラメータを特定。

2. **矛盾の抽出**  
   - 技術的矛盾を「改善パラメータ vs 悪化パラメータ」で整理。

3. **矛盾行列の活用**  
   - 39×39の行列から該当するセルを参照し、推奨される発明的原則を抽出（例：速度↑→エネルギー損失↓ → 原則「周期的動作」「反対方向の作用」）。

4. **アイデア生成**  
   - 抽出された原則を元に具体的な解決策を創出。

5. **評価と実装**  
   - 可能性の高いアイデアをスクリーニングし、プロトタイプ化や最適化。

---

#### **発明事例：新幹線「はやぶさ」の鼻形設計**
**背景**  
- 高速走行時のトンネル突入時に「マイクロプレッシャーウェーブ」（轟音）が発生。  
- 矛盾：速度向上（改善パラメータ）と騒音低減（悪化パラメータ）の両立。

**TRIZプロセス**  
1. **矛盾の抽出**  
   - 改善：速度（パラメータ19「運動物体の速度」）  
   - 悪化：騒音（パラメータ31「有害作用の発生」）

2. **矛盾行列の適用**  
   - 推奨された発明的原則：  
     - **原理17「次元変換」**（2D→3D、時間軸の導入）  
     - **原理1**「分割」、**原理28**「機械的代替」

3. **アイデア生成**  
   - 「次元変換」から、先頭車両の形状を流体力学的に最適化。  
   - 鳥類（カワセミ）のくちばしの形状（細長く先細）に着目し、空気抵抗を低減するデザインを考案。

4. **実装と成果**  
   - 新設計により騒音を75%削減し、速度は300km/hに達成。  
   - エネルギー効率も向上し、運行コストを約10%削減。

---

#### **TRIZの応用範囲**
- **製品設計**：軽量化と強度確保（例：航空機部品の3Dプリンティング）。  
- **プロセス改善**：製造ラインの非効率解消（例：ロボットアームの動作最適化）。  
- **サービス開発**：顧客満足度とコストの両立（例：オンライン診療の導入）。

TRIZは「発明のアルゴリズム」とも呼ばれ、既存知識の再利用を通じて創造的な解決策を導き出すツールとして、多くの企業（三星、ボーイング、トヨタなど）で活用されています。

---

D先生： “こんなもん、LLMで半自動化できるでしょう。”

QEU:FOUNDER ： “「半自動化」ねえ、確かに・・・。LLMを使えば、面倒くさいと敬遠されたTRIZをLLM上で低コストで完結することは可能でしょう。まあ、どちみち、次は**BONSAI**です。”

![imageSIWC2-44-12](/2025-05-23-QEUR23_SIWC43/imageSIWC2-44-12.jpg) 

C部長： “まあ、**TRIZはディベートの一種**ですからね。”

